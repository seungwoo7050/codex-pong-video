# v0.3.0 백엔드 설계 - 실시간 게임/매칭

## 1. 목적과 범위
- 실시간 1:1 게임 방을 생성/삭제하고 참가자를 관리한다.
- 틱 기반 게임 엔진으로 공/패들/점수를 authoritative하게 계산한다.
- 간단한 "빠른 대전" 큐로 두 사용자를 자동 매칭한다.
- 경기 종료 시 결과를 User 엔티티와 연결해 DB에 저장한다.

## 2. 아키텍처 개요
- 패키지
  - `game.domain`: `GameRoom` 등 방 상태 모델
  - `game.engine`: `GameEngine`, `GamePhysicsState` 등 물리 계산
  - `game.service`: `GameRoomService`, `MatchmakingService`
  - `game`: WebSocket/REST 컨트롤러
- WebSocket: `/ws/game` (JWT 핸드셰이크) → 실시간 입력/상태 전송
- REST:
  - `POST /api/match/quick`: 큐 등록
  - `GET /api/match/quick/{ticketId}`: 매칭 상태 확인
  - `GET /api/games`: 최근 경기 기록 조회

## 3. 도메인 및 엔진
- `GameRoom`
  - 두 명의 `User`를 포함하고 `GameEngine`을 보유.
  - 입력 맵을 저장하고 틱마다 스냅샷을 반환.
- `GameEngine`
  - 50ms 틱, 800x480 코트, 목표 점수 5점.
  - 패들 이동/벽 반사/패들 충돌/득점 시 공 리셋.
- 상태 저장
  - `GameSnapshot`: 공/패들 좌표, 속도, 점수, 종료 여부.

## 4. 매칭 흐름
- `MatchmakingService`
  - 메모리 큐로 대기열 관리, 동일 사용자 중복 대기 방지.
  - 2명 확보 시 `GameRoomService.createRoom` 호출 후 티켓에 roomId 부여.
- `GameRoomService`
  - 방/세션/루프 관리, 50ms 스케줄러로 tick 실행 후 상태 브로드캐스트.
  - 종료 시 `GameResultService`로 영속화 후 방 정리.

## 5. API/계약
- `POST /api/match/quick`
  - JWT 필수. 응답: `{ ticketId, status, roomId? }`
- `GET /api/match/quick/{ticketId}`
  - JWT 필수. 자신의 티켓만 조회, `MATCHED` 시 roomId 포함.
- `GET /api/games`
  - JWT 필수. 최근 20건의 `{playerAId, playerANickname, ... , finishedAt}` 반환.
- WebSocket `/ws/game`
  - 쿼리: `roomId`, `token`
  - 수신: `{ type: "INPUT", roomId, direction }`
  - 송신: `{ type: "READY"|"STATE", snapshot }`

## 6. 데이터 모델
- `game_results`
  - `id` PK, `player_a_id` FK, `player_b_id` FK
  - `score_a`, `score_b`, `room_id`
  - `started_at`, `finished_at`
- `GameResultService.recordResult`가 방 종료 시 기록.

## 7. 테스트 전략
- 단위
  - `GameEngineTest`: 이동/득점 검증.
  - `MatchmakingServiceTest`: 두 사용자 매칭 시 roomId 생성 확인.
- 통합
  - `GameResultControllerTest`: 인증 후 기록 조회 가능 여부.

## 8. 한계 및 TODO
- 매칭/방 상태가 메모리에만 존재하므로 서버 재시작 시 사라진다.
- 패들 입력 디바운스, 재연결 처리, 관전자 모드는 향후 버전에서 확장.
